# Folge 286 - Transkription und Code für den Stream: LLMs - Süßes oder Saures?

Vielleicht erinnerst du dich noch, dann habe ich gesagt, ja gut, dann lassen wir es bleiben, weil mehr Aufwand wollte ich nicht erzeugen.

Und das finde ich so spannend, weil momentan sucht jeder in der Wirtschaft nach dem KI-Use-Case, mit dem man Einsparungen erzielen kann.

Und hier war das für mich so wichtig, weil ja, wir wollten ja eigentlich nicht mehr Aufwand haben.

Aber du hast dann gesagt, dass der Mehrwert so hoch ist, dass es sich eben lohnt, diesen Mehraufwand reinzusetzen.

Das heißt, die KI hat uns hier enabled, etwas zu erzeugen, was wir vorher nicht konnten.

Und es hat diesen Wert, dass wir bereit sind, den Mehraufwand für das Laufenlassen, den Review und sowas zu investieren.

Und das fand ich für mich auch nochmal ein Schlüsselmoment, weil es muss nicht unbedingt irgendwie sein, dass ich das gegenüber dem Status Quo was spare, sondern dieses Enablement durch die KI finde ich wichtig.

Ja, also zwei Sachen dazu.

Die eine Sache ist halt das Reviewen dieser Episoden.

Also wahrscheinlich kann man das auch an den GitHub-Historien sich anschauen.

Das sind halt eine Zusammenfassung und Stichworte.

Fünf Minuten, zehn Minuten, das ist halt kein echter Aufwand.

Dann kommt halt das Transkript dazu.

Das ist halt diese Geschichte mit dem Anfang abschneiden.

Das ist halt das MP3 und das MP3 hat ein Intro.

Da haben wir auch nur zwei Runden drüber gedreht, wo erst die Idee war, das Intro abzuschneiden in der Pipeline.

Wo wir dann gesagt haben, wir lassen das halt drin und benotieren es halt raus.

Und dann halt irgendwie noch in dem Transkript Sachen ändern, falls da Dinge sind, die aufgefallen sind und das halt irgendwie zu lösen.

So, das heißt der Aufwand ist gering.

Und der Grund, warum ich das… Also die Transkripte sind einfach für Gehörlose, glaube ich, offensichtlich wichtig.

Die brauchen halt sowas.

Und deswegen fand ich das eben wichtig, sowas auf die Reihe zu bekommen.

Und wir hätten es sonst nicht hinbekommen.

Ich hatte ja das Vergnügen, aus der Nähe zu sehen, wie der InnoCube-Podcast entsteht.

Da sind halt Menschen gewesen, die das Transkriptieren.

Dann ist halt noch jemand drüber gegangen und hat es irgendwie nacheditiert, weil die übrigens auch ähnliche Schwierigkeiten haben.

Also wenn da Begriffe sind, die die Menschen nicht kennen, dann ist das halt ein Problem und das muss im Manuell nachgearbeitet werden.

Und den Aufwand können wir halt nicht leisten.

Niemand von uns kann sich hinsetzen und das Ding anhören und darunter schreiben.

Und wir können eigentlich auch nicht ernsthaft jemanden dafür bezahlen, weil wir im Prinzip kein Budget haben.

Und deswegen ist das die einzige Möglichkeit, Transkripte zu bekommen.

Und das ist eben auch tatsächlich wichtig.

Und bei den Zusammenfassungen habe ich eben selber gemerkt, dass die… Also ich empfinde sie zumindest als nützlich, weil ich da nochmal eine Idee davon habe, was in der Episode passiert ist.

Und deswegen fand ich das halt gut.

Und das ist ja auch vielleicht das Allgemeine.

Ich habe darüber auch bei Heise mal so einen Artikel geschrieben, eben auch in Bezug auf AI.

Wenn wir jetzt also mehr Produktivität haben, was auch immer das bedeutet.

Also wir haben jetzt ja die Möglichkeit, mit wenig Aufwand eben diese Sachen zu erzeugen mit AI.

Und dadurch sind wir halt in dem Bereich produktiver.

Also wenn ich jetzt die Zusammenfassung schreiben würde oder die Stichworte, wenn wir die schreiben würden, das würde halt viel länger dauern.

Und dadurch machen wir halt mehr.

Und da gibt es einen Begriff für Rebound-Effekt.

Ich glaube, so heißt der.

Rebound.

Genau.

Wo du halt sagst, wenn etwas billiger wird, einfacher wird, dann wird es irgendwie für neue Sachen genutzt und halt mehr genutzt.

Und wenn also Sachen eben stromeffizienter werden, dann nutzt man halt mehr davon.

Und das ist glaube ich das, was wir hier beobachten in gewisser Weise.

Und das ist auch das, was ich in diesem heißen Blogpost geschrieben habe, weil ich eben nicht erwarten würde, dass wenn wir tatsächlich höher Produktivität durch AI haben.

Das ist meiner Ansicht nach eine offene Frage, aber das ist eine andere Diskussion.

Dann ist die nächste Frage, ob das durchschlägt zu weniger Menschen, die halt arbeiten.

Mindestens in der Softwareentwicklung ist es so, dass wir hoffentlich, glaube ich, die ganze Zeit Produktivitätsvorteile haben.

Und ich würde behaupten, jetzt oder vor einiger Zeit, also bevor dieser Downturn bei uns war in unserer Branche, zu dem Zeitpunkt gab es halt die meisten EntwicklerInnen.

Trotzdem, dass die viel produktiver sind als die vor zehn Jahren oder so.

Und deswegen bin ich halt sehr unsicher, ob wir dann tatsächlich in einer sozusagen Massenarbeitslosigkeit haben werden.

Ich würde eher erwarten, dass wir halt andere Sachen dann noch produzieren.

Hier haben wir im Prinzip genau das, wie du gerade sagtest, als kleines Beispiel.

Ja, definitiv.

Bei mir schwingt das Pendel hin und her.

Und ich sehe, dass manche Sachen die KI gut machen kann.

Sie kann mich enablen, sie kann mich unterstützen.

Und andere Sachen, die klappen irgendwie ganz schlecht.

Also die Transcriptions, die lagen eine Weile dann so rum, weil das Problem war, ja, ich hatte das Skript, aber ich musste dann immer es laufen lassen.

Er hat irgendwie acht bis zehn Minuten gebraucht.

Dann musste ich ein Pull-Request erstellen und habe mir gedacht, eigentlich müsste ich es automatisieren.

Und das war dann nämlich so der nächste Aha-Effekt, weil wir kennen das ja mit den Pipelines, die dann irgendwie nur auf dem Server laufen, die man irgendwie schlecht lokal ausprobieren kann und so.

Und ich glaube, ich hatte da einen gemischten Ansatz, dass ich einmal den GitHub Copilot mit Issues gefüttert habe, direkt auf GitHub.com und einmal, dass ich es lokal gemacht habe und meiner KI Zugriff über das Command-Line-Tool GH auf die Workflows gegeben habe, dass es eben gucken konnte, wie sie laufen.

Und ehrlich gesagt, das war eine Katastrophe.

Da hat er sich total schwer getan.

Ich habe auch das Gefühl, ich habe den Code nicht reviewed.

Das lief alles irgendwie nebenbei.

Mach mal und teste mal und schau mal, ob es funktioniert.

Und ich habe die Befürchtung, dass er viel Code dupliziert hat.

Also er hat angefangen.

Es war irgendwie so eine Zeit, wo die Modelle sehr gern Back-Files angelegt haben, Backup-Files oder neue Versionen von den Files, obwohl ich immer gesagt habe, du bist hier unter Versionskontrolle, musst du nicht machen.

Und er hatte eben auch Probleme mit den Berechtigungen, dass er halt von meinem Repository in das Software-Architektur im Stream Repository das Ganze pushen kann.

Und da war ich sehr froh, als es dann irgendwann lief.

Aber es kam mir fragil vor.

Das Code weiß nicht.

Also die Code-Basis ist da, glaube ich, nicht mehr so gut.

Läuft, aber fragil.

Und da bin ich dann noch zu einem Moment gekommen, wo ich gemerkt habe, geht so gar nicht.

Weil irgendwann, ich wollte die Transkription anschmeißen und er lief auf einen Berechtigungsfehler und nichts ging.

Ich habe die KI angeschmissen, habe gesagt, guck mal da Fehler, fix das.

Ich war mir nicht so sicher, ob ich da noch irgendwie mit der KI was geändert hatte, das dadurch broken war.

Und die KI so, ach ja, klar, warum hast du hier ein Personal Access Token?

Können wir doch rausschmeißen, weil du hast ja hier Berechtigung in der Action und hat das rausgeschmissen.

Und dann haben wir es ausprobiert und dann ist weiter unten ein Berechtigungsfehler passiert.

Und da ist mir auf einmal ein Licht aufgegangen.

Er wollte dann schon anfangen und weiter unten den Berechtigungsfehler auch beheben.

Aber das eigentliche Problem war ein ganz anderes, denn ich hatte ein temporäres Personal Access Token gesetzt und diese Berechtigung war ausgelaufen.

Das hätte er eigentlich erkennen müssen.

Aber er hat eben da rumgefummelt am Code, hat nicht den eigentlichen Grund gefunden und hätte den Code jetzt komplett umgeschmissen und sich in komischen Sachen verrannt.

Das Ding ist, im ersten Stück reichen die normalen Berechtigungen aus, Open Source Repository Pullen.

Im zweiten Bereich braucht es Personal Access Token, um zu pushen oder den Pull Request zu stellen.

Und das war ihm nicht aufgefallen.

Und da habe ich gemerkt, dass er eben in diesem relativ kleinen Stück Code anscheinend den Überblick verloren hat, das mentale Modell über seinen eigenen Code nicht mehr bewahrt hat und deswegen das nicht editieren oder fixen konnte.

Genau, also nochmal ein Reminder.

Nicht die Dinger sind Textgeneratoren, sodass sie auf Basis von dem, was sie reinbekommen haben, einen Text generieren.

Ich würde behaupten, es gibt da kein mentales Modell, aber nicht die Type.

Das andere ist, ich finde, das ist halt ein, also wie soll ich sagen, wir kommen ja noch dazu, wie wir es auf die Webseite tun und was ich mittlerweile bei mir, wenn ich halt irgendwelche Sachen mache, wie zum Beispiel jetzt die Webseite editieren, was mir da zugutekommt, ist, dass ich mit Chitchipiti die Möglichkeit habe, irgendwie zu sagen, okay, sagt mir mal, wie ich dieses oder jenes auf die Reihe bekomme.

Und da kommen halt gute Vorschläge.

Das bedeutet aber, dass ich halt im Prinzip mir Webrecherche nur spare.

Das, was du ja beschreibst, ist eigentlich, mach mal und implementier mal.

Und das, was du jetzt gerade beschreibst, ist ein gutes Beispiel, um es platt zu sagen, das funktioniert eigentlich nicht.

Denn was an irgendeiner Stelle dann immer wieder passiert, ist genau das, was wir jetzt hier gerade sehen.

Du fängst irgendwie an und sagst, naja, das funktioniert ja so und so und so.

Und da sind folgende Themen, also ein Security-Thema an dieser Stelle, das müssen wir irgendwie fixen.

Und dann musst du halt in diese Abstraktion reingreifen.

Du bist jetzt irgendwie nicht mehr auf dieser Ebene, dass du sagst, mach mal und löse mal.

Mir egal.

Ich will nicht verstehen, wie es funktioniert, sondern du musst es ja mal verstehen.

Es gibt halt GitHub.

GitHub hat irgendwelche Security-Tokens.

Da gibt es offensichtlich Lokale und andere.

Und irgendwie ist da etwas schief.

Und deswegen muss ich das halt fixen.

Was halt bedeutet, ich komme eben nicht auf die höhere Abstraktionsschicht, sondern an bestimmten Stellen bricht es eben und ich muss irgendwie reingreifen.

Das beobachte ich an extrem vielen Stellen, was eben dazu führt, dass ich mir überhaupt gar nicht vorstellen kann, wie nicht EntwicklerInnen damit irgendetwas auf die Reihe bekommen sollen.

Weil an der Stelle werden sie halt gescheitert.

Und dann ist halt Schluss.

Weil eben solche Menschen dann da nicht reingreifen können und sagen können, ach so, ja klar, das funktioniert ja folgendermaßen.

Eben nicht Security-Token.

So funktioniert die Security.

Das ist halt GitHub.

Sondern die können das dann eben auf der Ebene nicht mehr verfolgen und dann ist eben Schluss.

Absolut.

Und du hattest gerade eben schon gesagt, ja das Modell kann ja kein mentales Modell aufbauen.

Und wir hatten vorher die Vermenschlichung.

Aber ich habe mich jetzt seit ein paar Wochen mit dem mentalen Modell nach Peter Nauer beschäftigt.

85 war das, glaube ich, als er das so beschrieben hat.

Und das Witzige ist, also das mentale Modell beschreibt halt, was man als Entwickler so aufbaut beim Programmieren, um eben auch die Frage nach dem Warum im Code beantworten zu können.

Warum wird da ein Personal Access-Token und nicht einfach der Access-Key, den man in der Action hat, verwendet, zum Beispiel.

Und das Faszinierende ist, dass die Modelle dieses Konzept, mentales Modell nach Nauer kennen und dann wissen, was sie zu tun haben, also was es bedeutet.

Und die ganzen Tool-Hersteller haben schon angefangen.

Man kennt das ja, diese Cloud.md oder Agent.md-Files, die immer im Root liegen, wo die KI mal über das Repository rübergegangen ist und zumindest sich wichtige Sachen wie Technology-Stack und die File-Struktur und sowas rausgeschrieben hat.

Gehört auch zum mentalen Modell.

Ich behaupte, dass wenn man eben auch so ein bisschen an dieses Warum geht, wenn man jetzt eben zum Beispiel da das hinterlassen würde, wir benutzen hier Personal Access-Token, weil erster Weg ohne Personal Access-Token hat nicht funktioniert.

Deswegen, wenn man das hinterlässt, dann könnte die KI da besser werden.

Und das zeigt eben auch, dass, ja, du sagst ja selbst, wenn man jetzt das Programmieren noch nicht gewöhnt ist, nicht jahrelang trainiert hat, dann fallen einem diese Sachen nicht auf.

Und dann ist die Frage, ob man es schafft, das Modell richtig zu besprechen, also die Prompts richtig zu wählen.

Und das macht einen großen Unterschied aus.

Genau, also vielleicht noch zwei Worte dazu.

Es ist halt ganz spannend, weil der Sebastian Hans hat mich vor fünf Tagen, so sagt Mastodon, auf dieses Paper hingewiesen, Programming as Theory Building.

Und ich hatte mir irgendwie sozusagen vorgenommen, das nochmal genauer durchzulesen, weil ich halt vermutet hatte, dass das halt im Prinzip bedeutet, dass man eben als Menschenteam ein gemeinsames mentales Modell entwickelt und dass sich im Code das eben nur ausdrückt.

Ich hatte die ersten Seiten überflogen und da war so eine Geschichte, von wegen irgendein Team hat einen Compiler gebaut oder irgendwas.

Dann hat ein anderes Team versucht, den zu erweitern.

Und daraufhin hat man das dem ursprünglichen Team gegeben und hat gesagt, das ursprüngliche Team, was den Compiler ursprünglich gebaut hat, hat gesagt, das ist ein netter Versuch, aber das zerstört die ganze Struktur des Systems.

Und hier ist ein viel einfacherer Weg.

Und das hängt eben damit zusammen, dass das ursprüngliche Team diese Theorie verstanden hat und das neue Team nicht.

So jedenfalls meine Wahrnehmung.

Das, was du beschreibst, bedeutet ja nur, dass man in den Texten etwas hinschreibt.

Das ist kein mentales Modell.

Und das ist was anderes.

Darüber muss man offensichtlich, weil das wäre dann sozusagen die nächste Episode, die man nochmal planen könnte und machen könnte.

Absolut.

Der Begriff mentales Modell ist da vielleicht auch ein bisschen schwierig.

Aber ich habe halt gemerkt, da ist was dran an diesem mentalen Modell.

Und wie du ja gesagt hast, die KI nimmt Text und produziert Text.

Das heißt, man muss irgendwo, wenn man es schaffen will, im Text abbilden.

Aber das Faszinierende daran ist auch, wenn man dieses Konzept betrachtet und jetzt zum Beispiel Legacy Modernisation machen möchte mit der KI und sagt, warum ist dieser Code eigentlich Legacy?

Weil die Entwickler sagen alle, muss neu geschrieben werden.

Warum muss er neu geschrieben werden?

Weil das mentale Modell fehlt, weil das Warum fehlt.

Und wenn ich dann mit der KI es umschreiben lasse, in eine moderne Sprache, habe ich dann das mentale Modell.

Kann dann der Entwickler weiterarbeiten?

Das finde ich so faszinierend.

Eine interessante Erkenntnis.

Meiner Ansicht nach ist das Grundproblem dabei, dass man an der Stelle nicht wahrhaben will, dass Schriftverentwicklung ein sozialer Prozess ist.

Und das ist das, was ich glaubte, was man aus diesem Paper, was ich eben nicht gelesen habe, vielleicht rauslesen kann.

Dass dieses soziale Modell im Code Ausdruck findet.

Und das ist dann halt trivial, wenn ich eine AI ansetze, dass das dieses mentale Modell und den sozialen Prozess nicht abbildet.

Und dann ist halt Schluss.

Das ist eine Vielkonzeption.

Und das ist eine von den Sachen, die mich so ärgert.

In diesem AI-Bereich ist eine Vielkonzeption über Softwareentwicklung.

Softwareentwicklung ist ein sozialer Prozess.

Und die fundamentalen Schwierigkeiten sind meiner Ansicht nach sozial.

Und das wird nicht dadurch besser, dass ich eine Maschine da reinsetze.

Aber anderes Thema.

Wir sollten offensichtlich noch eine Episode mindestens planen.

Wollen wir sprechen, wie du es auf die Webseite bekommen hast?

Ich würde ganz gern jetzt schon mal auf die andere Idee eingehen.

Wegen dem sozialen Prozess.

Weil ich das so faszinierend fand.

Ich kam dann irgendwie auf die Idee, dass man ja auch mal die Folgen nach Gast sortieren könnte und auf die Seite bringen könnte.

War irgendwie so eine Idee.

Könnte man doch mal machen.

Und die Idee dabei war halt, also ich finde diese verschiedenen Ebenen, wie man die KI verwendet.

Und wir haben jetzt zum Beispiel bei dem Transkriptionsprozess habe ich mit KI gekodet.

Wir haben mit KI machen wir ein Review.

Und in dem Prozess, die Zusammenfassung, läuft ja selbst auch mit KI.

Müssen wir gleich auch dran denken.

Da gibt es ja jetzt ein aktuelles Problem, was wir haben.

Und so habe ich dann eben auch gedacht, Mensch, wir haben jetzt diese ganzen 180 Folgen.

Wow, da hat sich was angesammelt.

Und da ist überall irgendwo unstrukturiert der Gast mit genannt.

Und das könnte man ja jetzt mit der KI rausziehen.

Und ich habe einfach mal die KI drauf angesetzt.

Habe gesagt, guck mal, hier ist das Repository und mach dir mal Gedanken, wie könnte man das rausziehen.

Iterier mal drüber.

Da war es schon mal faszinierend, weil ich gesagt habe, du KI kannst du bitte drüber iterieren.

Und die KI hat gesagt, ich mache mir mal einen Plan.

Und der Plan sind eigentlich maximal fünf Schritte bei Claude.

Das heißt, erster Schritt, erste Episode, Gast rausziehen.

Zweite Episode, Gast rausziehen.

Dritte Episode, Gast rausziehen.

Vierte Episode, Gast rausziehen.

Aus den anderen Episoden, Gast rausziehen.

Und genau so hat das Modell dann gearbeitet.

Mit den ersten vier Episoden ist gut klargekommen.

Und dann ist es abgedriftet und konnte nicht mehr iterieren.

Da habe ich dann gemerkt, es könnte ja ein Programm schreiben, ein Skript, was iteriert.

Und dann in dem Skript habe ich aber die KI wieder nicht mehr zur Verfügung, um das zu extrahieren.

Das war so ein Ding, was ich dann da angegangen bin.

Aber viel faszinierender fand ich es, als das Ganze irgendwo stand, mehr oder weniger fertig war.

Ja, da waren viele Fehler drin.

Aber du dann drüber geguckt hast und ich irgendwie gemerkt habe, dass du mir freundlich sagen wolltest, Ralf, das was da rausgekommen ist, das ist totaler Käse, weil das passt überhaupt nicht zur bestehenden Architektur.

War so, richtig?

Also genau, soll ich kurz sozusagen ausholen.

Also die eine Sache war halt, wir haben ja eine Jacke-basierte Webseite.

Das heißt, wir haben im Prinzip Markdown-Files, die hat irgendwie gerendert werden mit Ruby-Skripten.

Und das macht eben, in Produktion macht das halt GitHub-Pages.

Und im Prinzip ist das ja ein CMS.

Das heißt, ich habe Content, der ist als MD-Files da und dann wird er irgendwie gerendert.

Und was jetzt irgendwie rausgekommen ist, in deinem Fall war eine MD-Seite, die aber in Wirklichkeit HTML hatte.

Also in Markdown kann ich HTML einbetten und JavaScript-Code.

Und wo dann im Prinzip alle Gäste rausgesammelt wurden aus, ich weiß nicht, irgendeiner Datenquelle, YAML-File oder so.

Und wenn ich dann etwas gesucht habe, hat das halt der JavaScript-Code auf dem Client gemacht.

Das ist wahrscheinlich die einzige Möglichkeit, wie man das hinbekommen kann.

Also meine, wie soll ich sagen, meine Intuition wäre halt, ich will eigentlich irgendwo einen Server haben, der halt sucht.

Das können wir nicht, weil wir GitHub-Pages nur haben.

Und deswegen ist das wahrscheinlich der einzige Weg.

Was sich da in meiner Erinnerung aber so gezeigt hat, ist, dass das so aufgepfropft wird.

Also wir haben CSS-Files, wie sich das gehört.

Und ich würde jetzt erwarten, dass diese CSS-Sachen wiederverwendet werden.

Werden halt nicht wiederverwendet, da ist halt irgendwie eigener Kram drin.

Solche Sachen halt nicht.

Es ist halt was Eigenes, was halt getrennt ist von dem Rest, zum Beispiel in Bezug auf CSS oder nicht eigene JavaScript-Dateien oder so.

Und das andere ist halt, also das hat mich dazu gerade sozusagen angestiftet, das sozusagen deutlich zu sagen.