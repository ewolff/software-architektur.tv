# Folge 286 - Transkription und Code für den Stream: LLMs - Süßes oder Saures?

Vielleicht erinnerst du dich noch, dann habe ich gesagt, ja gut, dann lassen wir es bleiben, weil mehr Aufwand wollte ich nicht erzeugen.

Und das finde ich so spannend, weil momentan sucht jeder in der Wirtschaft nach dem KI-Use-Case, mit dem man Einsparungen erzielen kann.

Und hier war das für mich so wichtig, weil ja, wir wollten ja eigentlich nicht mehr Aufwand haben.

Aber du hast dann gesagt, dass der Mehrwert so hoch ist, dass es sich eben lohnt, diesen Mehraufwand reinzusetzen.

Das heißt, die KI hat uns hier enabled, etwas zu erzeugen, was wir vorher nicht konnten.

Und es hat diesen Wert, dass wir bereit sind, den Mehraufwand für das Laufenlassen, den Review und sowas zu investieren.

Und das fand ich für mich auch nochmal ein Schlüsselmoment, weil es muss nicht unbedingt irgendwie sein, dass ich das gegenüber dem Status Quo was spare, sondern dieses Enablement durch die KI finde ich wichtig.

Ja, also zwei Sachen dazu.

Die eine Sache ist halt das Reviewen dieser Episoden.

Also wahrscheinlich kann man das auch an den GitHub-Historien sich anschauen.

Das sind halt eine Zusammenfassung und Stichworte.

Fünf Minuten, zehn Minuten, das ist halt kein echter Aufwand.

Dann kommt halt das Transkript dazu.

Das ist halt diese Geschichte mit dem Anfang abschneiden.

Das ist halt das MP3 und das MP3 hat ein Intro.

Da haben wir auch nur zwei Runden drüber gedreht, wo erst die Idee war, das Intro abzuschneiden in der Pipeline.

Wo wir dann gesagt haben, wir lassen das halt drin und benotieren es halt raus.

Und dann halt irgendwie noch in dem Transkript Sachen ändern, falls da Dinge sind, die aufgefallen sind und das halt irgendwie zu lösen.

So, das heißt der Aufwand ist gering.

Und der Grund, warum ich das… Also die Transkripte sind einfach für Gehörlose, glaube ich, offensichtlich wichtig.

Die brauchen halt sowas.

Und deswegen fand ich das eben wichtig, sowas auf die Reihe zu bekommen.

Und wir hätten es sonst nicht hinbekommen.

Ich hatte ja das Vergnügen, aus der Nähe zu sehen, wie der InnoCube-Podcast entsteht.

Da sind halt Menschen gewesen, die das Transkriptieren.

Dann ist halt noch jemand drüber gegangen und hat es irgendwie nacheditiert, weil die übrigens auch ähnliche Schwierigkeiten haben.

Also wenn da Begriffe sind, die die Menschen nicht kennen, dann ist das halt ein Problem und das muss im Manuell nachgearbeitet werden.

Und den Aufwand können wir halt nicht leisten.

Niemand von uns kann sich hinsetzen und das Ding anhören und darunter schreiben.

Und wir können eigentlich auch nicht ernsthaft jemanden dafür bezahlen, weil wir im Prinzip kein Budget haben.

Und deswegen ist das die einzige Möglichkeit, Transkripte zu bekommen.

Und das ist eben auch tatsächlich wichtig.

Und bei den Zusammenfassungen habe ich eben selber gemerkt, dass die… Also ich empfinde sie zumindest als nützlich, weil ich da nochmal eine Idee davon habe, was in der Episode passiert ist.

Und deswegen fand ich das halt gut.

Und das ist ja auch vielleicht das Allgemeine.

Ich habe darüber auch bei Heise mal so einen Artikel geschrieben, eben auch in Bezug auf AI.

Wenn wir jetzt also mehr Produktivität haben, was auch immer das bedeutet.

Also wir haben jetzt ja die Möglichkeit, mit wenig Aufwand eben diese Sachen zu erzeugen mit AI.

Und dadurch sind wir halt in dem Bereich produktiver.

Also wenn ich jetzt die Zusammenfassung schreiben würde oder die Stichworte, wenn wir die schreiben würden, das würde halt viel länger dauern.

Und dadurch machen wir halt mehr.

Und da gibt es einen Begriff für Rebound-Effekt.

Ich glaube, so heißt der.

Rebound.

Genau.

Wo du halt sagst, wenn etwas billiger wird, einfacher wird, dann wird es irgendwie für neue Sachen genutzt und halt mehr genutzt.

Und wenn also Sachen eben stromeffizienter werden, dann nutzt man halt mehr davon.

Und das ist glaube ich das, was wir hier beobachten in gewisser Weise.

Und das ist auch das, was ich in diesem heißen Blogpost geschrieben habe, weil ich eben nicht erwarten würde, dass, also wenn wir tatsächlich höher Produktivität durch AI haben, ist meiner Ansicht nach eine offene Frage, aber das ist eine andere Diskussion, dann ist die nächste Frage, ob das durchschlägt zu weniger Menschen, die halt arbeiten.

Mindestens in der Softwareentwicklung ist es so, dass wir halt hoffentlich, glaube ich, die ganze Zeit Produktivitätsvorteile haben.

Und ich würde behaupten, jetzt oder vor einiger Zeit, also bevor irgendwie dieser Downturn bei uns war, in unserer Branche, zu dem Zeitpunkt gab es halt die meisten EntwicklerInnen.

Trotzdem, dass die halt viel produktiver sind als die vor zehn Jahren oder so.

Und deswegen bin ich halt sehr unsicher, ob wir dann tatsächlich sozusagen Massenarbeitslosigkeit haben werden.

Ich würde eher erwarten, dass wir halt andere Sachen halt dann noch produzieren.

Und hier haben wir im Prinzip genau das, wie du gerade sagtest, als kleines Beispiel.

Ja, definitiv.

Das ist auch bei mir, das Pendel schwingt hin und her.

Und ich sehe, dass manche Sachen die KI gut machen kann.

Sie kann mich enablen, sie kann mich unterstützen.

Und andere Sachen, die klappen irgendwie ganz schlecht.

Also die Transcriptions, die lagen eine Weile dann so rum, weil das Problem war, ja, ich hatte das Skript, aber ich musste dann immer es laufen lassen.

Das hat irgendwie acht bis zehn Minuten gebraucht.

Dann musste ich ein Pull-Request erstellen und habe mir gedacht, eigentlich müsste ich es automatisieren.

Und das war dann nämlich so der nächste Aha-Effekt, weil wir kennen das ja mit den Pipelines, die dann irgendwie nur auf dem Server laufen, die man irgendwie schlecht lokal ausprobieren kann und so.

Und ich glaube, ich hatte da einen gemischten Ansatz, dass ich einmal den GitHub Copilot mit Issues gefüttert habe, direkt auf GitHub.com und einmal, dass ich es lokal gemacht habe und meiner KI Zugriff über das Command-Line-Tool GH auf die Workflows gegeben habe, dass es eben gucken konnte, wie sie laufen.

Und ehrlich gesagt, es war eine Katastrophe.

Also da hat er sich total schwer getan.

Ich habe auch das Gefühl, ich habe den Code nicht reviewed.

Ja, das lief alles irgendwie nebenbei.

Mach mal und teste mal und schau mal, ob es funktioniert.

Und ich habe die Befürchtung, dass er viel Code dupliziert hat.

Also er hat angefangen.

Es war irgendwie so eine Zeit, wo die Modelle sehr gern Bug-Files angelegt haben, Backup-Files oder neue Versionen von den Files, obwohl ich immer gesagt habe, du bist hier unter Versionskontrolle, musst du nicht machen.

Und er hatte eben auch Probleme mit den Berechtigungen, dass er halt von meinem Repository in das Software-Architektur im Stream Repository das Ganze pushen kann.

Und da war ich sehr froh, als es dann irgendwann lief.

Aber es kam mir fragil vor.

Das Code weiß nicht.

Also die Code-Basis ist da glaube ich nicht mehr so gut.

Läuft, aber fragil.

Und da bin ich dann noch zu einem Moment gekommen, wo ich gemerkt habe, geht so gar nicht.

Weil irgendwann, ich wollte die Transkription anschmeißen und er lief auf einen Berechtigungsfehler und nichts ging.

Ich habe die KI angeschmissen, habe gesagt, guck mal da Fehler, fix das.

Ich war mir nicht so sicher, ob ich da noch irgendwie mit der KI was geändert hatte, das dadurch broken war.

Und die KI so, ach ja, klar, warum hast du hier einen Personal Access Token?

Können wir doch rausschmeißen, weil du hast ja hier Berechtigung in der Action und hat das rausgeschmissen.

Und dann haben wir es ausprobiert und dann ist weiter unten ein Berechtigungsfehler passiert.

Und da ist mir auf einmal ein Licht aufgegangen.

Er wollte dann schon anfangen und weiter unten den Berechtigungsfehler auch beheben.

Aber das eigentliche Problem war ein ganz anderes, denn ich hatte ein temporäres Personal Access Token gesetzt und diese Berechtigung war ausgelaufen.

Das hätte er eigentlich erkennen müssen.

Aber er hat eben da rumgefummelt am Code, hat nicht den eigentlichen Grund gefunden und hätte den Code jetzt komplett umgeschmissen und sich in komischen Sachen verrannt.

Das Ding ist, im ersten Stück reichen die normalen Berechtigungen aus, Open Source Repository Pull.

Im zweiten Bereich braucht es das Personal Access Token, um zu pushen oder den Pull Request zu stellen.

Und das war ihm nicht aufgefallen.

Und da habe ich gemerkt, dass er eben in diesem relativ kleinen Stück Code anscheinend den Überblick verloren hat, das mentale Modell über seinen eigenen Code nicht mehr bewahrt hat und deswegen das nicht editieren oder fixen konnte.

Genau, also nochmal ein Reminder sozusagen.

Nicht die Dinger sind Textgeneratoren, sodass sie auf Basis von dem, was sie reinbekommen hat, irgendwelchen Text generieren.

Ich würde behaupten, es gibt da kein mentales Modell.

Aber nicht die Type.

Das andere ist, wir kommen ja noch dazu, wie wir es auf die Webseite tun.

Und was ich mittlerweile bei mir, wenn ich irgendwelche Sachen mache, wie zum Beispiel jetzt die Webseite editieren, was mir da zugutekommt, ist, dass ich mit ChitchiPT die Möglichkeit habe, zu sagen, okay, sagt mir mal, wie ich dieses oder jenes auf die Reihe bekomme.

Da kommen gute Vorschläge.

Das bedeutet aber, dass ich mir im Prinzip Webrecherche nur spare.

Das, was du ja beschreibst, ist eigentlich, mach mal und implementiere mal.

Und das, was du jetzt gerade beschreibst, ist ein gutes Beispiel, um es platt zu sagen, das funktioniert eigentlich nicht.

Denn was an irgendeiner Stelle dann immer wieder passiert, ist genau das, was wir jetzt hier gerade sehen.

Du fängst an und sagst, naja, das funktioniert ja so und so und so.

Und da sind folgende Themen, also ein Security-Thema an dieser Stelle.

Das müssen wir fixen.

Und dann musst du halt in diese Abstraktion reingreifen.

Du bist jetzt nicht mehr auf dieser Ebene, dass du sagst, mach mal und löse mal.

Mir egal.

Ich will nicht verstehen, wie es funktioniert.

Sondern du musst dir verstehen, es gibt halt GitHub.

GitHub hat irgendwelche Security-Tokens.

Da gibt es offensichtlich Lokale und andere.

Und irgendwie ist da etwas schief.

Und deswegen muss ich das halt fixen.

Was bedeutet, ich komme eben nicht auf die höhere Abstraktionsschicht, sondern an bestimmten Stellen bricht es eben und ich muss irgendwie reingreifen.

Das beobachte ich an extrem vielen Stellen, was eben dazu führt, dass ich mir überhaupt gar nicht vorstellen kann, wie halt Nicht-EntwicklerInnen damit irgendetwas auf die Reihe bekommen sollen.

Weil an der Stelle werden sie halt gescheitert.

Und dann ist halt Schluss.

Weil eben solche Menschen dann da nicht reingreifen können und sagen können, ach so, ja klar, das funktioniert ja folgendermaßen.

Eben nicht Security-Token, so funktioniert die Security, das ist halt GitHub.

Sondern die können das dann eben auf der Ebene nicht mehr verfolgen und dann ist eben Schluss.

Absolut.

Und du hattest gerade eben schon gesagt, ja, das Modell kann ja kein mentales Modell aufbauen.

Und wir hatten die Vermenschlichung.

Aber ich habe mich jetzt seit ein paar Wochen mit dem mentalen Modell nach Peter Nauer beschäftigt.

1985 war das, glaube ich, als er das so beschrieben hat.

Und das Witzige ist, also das mentale Modell beschreibt halt, was man als Entwickler so aufbaut beim Programmieren, um eben auch die Frage nach dem Warum im Code beantworten zu können.

Warum wird da ein Personal Access Token und nicht einfach der Access Key, den man in der Action hat, verwendet, zum Beispiel.

Und das Faszinierende ist, dass die Modelle dieses Konzept, mentales Modell nach Nauer kennen und dann wissen, was sie zu tun haben, also was es bedeutet.

Und die ganzen Toolhersteller haben schon angefangen.

Man kennt das ja, diese Cloud.md oder Agent.md Files, die immer im Root liegen, wo die KI mal über das Repository rübergegangen ist und zumindest sich wichtige Sachen wie Technology Stack und die Fallstruktur und sowas rausgeschrieben hat.

Gehört auch zum mentalen Modell.

Ich behaupte, dass wenn man eben auch so ein bisschen an dieses Warum geht, wenn man jetzt eben zum Beispiel da das hinterlassen würde, wir benutzen hier Personal Access Token, weil erster Weg ohne Personal Access Token hat nicht funktioniert.

Deswegen, wenn man das hinterlässt, dann könnte die KI da besser werden.

Und das zeigt eben auch, dass ja, du sagst ja selbst, wenn man, wenn man jetzt das Programmieren noch nicht gewöhnt ist, es nicht jahrelang trainiert hat, dann fallen einem diese Sachen nicht auf.

Und dann ist die Frage, ob man es schafft, das Modell richtig zu besprechen, sag ich mal.

Ja, also die Prompts richtig zu wählen.

Und das macht einen großen Unterschied aus.

Genau.

Also vielleicht noch zwei Worte dazu.

Es ist halt ganz spannend, weil der Sebastian Hans hat mich vor fünf Tagen, so sagt Mastodon, auf dieses Paper hingewiesen, Programming as Theory Building.

Und ich hatte mir irgendwie sozusagen vorgenommen, das nochmal genauer durchzulesen, weil ich halt vermutet hatte, dass das halt im Prinzip bedeutet, dass man eben als Menschenteam ein gemeinsames mentales Modell entwickelt und dass sich im Code das eben nur ausdrückt.

Ich hatte das irgendwie, genau, ich hatte irgendwie die ersten Seiten überflogen und da war irgendwie so eine Geschichte, von wegen irgendein Team hat halt einen Compiler gebaut oder irgendwas.

Dann hat ein anderes Team versucht, den halt zu erweitern.

Und daraufhin hat das ursprüngliche Team, hat man das dem ursprünglichen Team gegeben und hat halt gesagt, also das ursprüngliche Team, was den Compiler ursprünglich gebaut hat, hat gesagt, das ist ein netter Versuch, aber das zerstört halt die ganze Struktur des Systems.

Und hier ist ein viel einfacherer Weg.

Und das hängt eben damit zusammen, dass eben das ursprüngliche Team halt diese Theorie verstanden hat und das neue Team nicht.

So jedenfalls meine Wahrnehmung.

Also das, was du beschreibst, bedeutet ja nur, dass man den Texten etwas hinschreibt.

Das ist kein mentales Modell.

Und das ist was anderes, aber nicht, dass, also darüber muss man offensichtlich, das wäre dann sozusagen die nächste Episode, die man nochmal planen könnte und machen könnte.

Absolut.

Der Begriff mentales Modell ist da vielleicht auch ein bisschen schwierig, aber ich habe halt gemerkt, da ist was dran an diesem mentalen Modell.

Und wie du ja gesagt hast, die KI nimmt Text und produziert Text.

Das heißt, man muss irgendwo, wenn man es schaffen will, im Text abbilden.

Aber das Faszinierende daran ist auch, wenn man dieses Konzept betrachtet und jetzt zum Beispiel Legacy Modernization machen möchte mit der KI und sagt, warum ist dieser Code eigentlich Legacy?

Weil die Entwickler sagen alle, muss neu geschrieben werden.

Warum muss er neu geschrieben werden?

Weil das mentale Modell fehlt, weil das Warum fehlt.

Und wenn ich dann mit der KI es umschreiben lasse, in eine moderne Sprache, habe ich dann das mentale Modell.

Kann dann der Entwickler weiterarbeiten?

Das finde ich so faszinierend, eine interessante Erkenntnis.

Meiner Ansicht nach ist das Grundproblem dabei, dass man an der Stelle nicht wahrhaben will, dass Softwareentwicklung ein sozialer Prozess ist.

Und das ist das, was ich glaubte, was man aus diesem Paper, was ich eben nicht gelesen habe, vielleicht rauslesen kann, dass eben dieses soziale Modell im Code Ausdruck findet.

Und das ist dann halt trivial, wenn ich eine AI ansetze, dass das eben dieses mentale Modell und den sozialen Prozess nicht abbildet.

Und dann ist halt Schluss.

Das ist eine Fehlkonzeption.

Und das ist eine von den Sachen, die mich so ärgert.

In diesem AI-Bereich ist eine Fehlkonzeption über Softwareentwicklung.

Softwareentwicklung ist ein sozialer Prozess.

Und die fundamentalen Schwierigkeiten sind meiner Ansicht nach sozial.

Und das wird nicht dadurch besser, dass ich eine Maschine da reinsetze, aber ein anderes Thema.

Wir sollten offensichtlich noch eine Episode mindestens planen.

Wollen wir sprechen, wie du es auf die Webseite bekommen hast?

Ich würde ganz gern jetzt schon mal auf die andere Idee eingehen, wegen dem sozialen Prozess, weil ich das so faszinierend fand.

Ich kam dann irgendwie auf die Idee, dass man ja auch mal die Folgen nach Gast sortieren könnte und auf die Seite bringen könnte.

War irgendwie so eine Idee, könnte man doch mal machen.

Und die Idee dabei war halt, also ich finde diese verschiedenen Ebenen, wie man die KI verwendet.

Und wir haben jetzt zum Beispiel bei dem Transkriptionsprozess habe ich mit KI gecodet.

Mit KI machen wir ein Review.

Und in dem Prozess, die Zusammenfassung, läuft ja selbst auch mit KI.

Da müssen wir gleich auch dran denken.

Da gibt es ja jetzt ein aktuelles Problem, was wir haben.

Und so habe ich dann eben auch gedacht, Mensch, wir haben jetzt diese ganzen 180 Folgen.

Wow, da hat sich was angesammelt.

Und da ist überall irgendwo unstrukturiert der Gast mit genannt.

Und das könnte man ja jetzt mit der KI rausziehen.

Und ich habe einfach mal die KI drauf angesetzt.

Habe gesagt, guck mal, hier ist das Repository und mach dir mal Gedanken, wie könnte man das rausziehen.

Iterier mal drüber.

Da war es schon mal faszinierend, weil ich gesagt habe, du KI, kannst du bitte drüber iterieren?

Und die KI hat gesagt, ja, ich mache mir mal einen Plan.

Und der Plan sind eigentlich maximal fünf Schritte bei Claude.

Das heißt, erster Schritt, erste Episode, Gast rausziehen.

Zweite Episode, Gast rausziehen.

Dritte Episode, Gast rausziehen.

Vierte Episode, Gast rausziehen.

Aus den anderen Episoden, Gast rausziehen.

Und genau so hat das Modell dann gearbeitet.

Mit den ersten vier Episoden ist es gut klargekommen.

Und dann ist es abgedriftet und konnte nicht mehr iterieren.

Da habe ich dann gemerkt, es könnte ja ein Programm schreiben, ein Skript, was iteriert.

Und dann in dem Skript habe ich aber die KI wieder nicht mehr zur Verfügung, um es zu extrahieren.

Das war so ein Ding, was ich dann da angegangen bin.

Aber viel faszinierender fand ich es, als das Ganze irgendwo stand, mehr oder weniger fertig war.

Ja, da waren viele Fehler drin.

Aber du dann drüber geguckt hast und ich irgendwie gemerkt habe, dass du mir freundlich sagen wolltest, Ralf, das, was da rausgekommen ist, das ist totaler Käse, weil das passt überhaupt nicht zur bestehenden Architektur.

War so.

Richtig?

Soll ich kurz ausruhen?

Die eine Sache war, wir haben ja eine Jekyll-basierte Webseite.

Das heißt, wir haben im Prinzip Markdown-Files, die gerendert werden mit Ruby-Skripten.

Und im Prinzip ist das ja ein CMS.

Das heißt, ich habe Content, der ist als MD-Files da und dann wird er gerendert.

Was jetzt rausgekommen ist, in deinem Fall war eine MD-Seite, die aber in Wirklichkeit HTML hatte.

In Markdown kann ich HTML einbetten und JavaScript-Code.

Und wo dann im Prinzip alle Gäste rausgesammelt wurden aus irgendeiner Datenquelle, YAML-File oder so.

Und wenn ich dann etwas gesucht habe, hat das der JavaScript-Code auf dem Client gemacht.

Das ist wahrscheinlich die einzige Möglichkeit, wie man das hinbekommen kann.

Meine Intuition wäre, ich will eigentlich irgendwo einen Server haben, der sucht.

Das können wir nicht, weil wir GitHub-Pages nur haben.

Und deswegen ist das wahrscheinlich der einzige Weg.

Was sich da in meiner Erinnerung aber so gezeigt hat, ist, dass das so aufgepfropft wird.

Wir haben CSS-Files, wie sich das gehört.

Und ich würde jetzt erwarten, dass diese CSS-Sachen wiederverwendet werden.

Werden halt nicht wiederverwendet, da ist halt irgendwie eigener Kram drin.

Solche Sachen.

Es ist halt was Eigenes, was halt getrennt ist von dem Rest, zum Beispiel in Bezug auf CSS oder nicht eigene JavaScript-Dateien oder so.

Und das andere ist halt, also das hat mich dazu gerade angestiftet, das sozusagen deutlich zu sagen, Die Implementierung war erschreckend.

Einmal ist es so, man konnte einen Gast auswählen, da gibt es dann die Episode, dann klickt man halt drauf, kriegt einen 404.

Okay, das ist die Basis-Funktionalität.

Und zwar, ich weiß nicht mehr, irgendwas stimmt an dem Link nicht.

Ich glaube, das ist mit Underbar Post und dem Datum, also nicht 2025 und so weiter und so weiter.

Da war irgendwas schief.

Irgendwie Verzeihnis fehlt oder so.

Aber in der Entwicklerin, die mir sowas abliefert, da würde ich zumindest ein Fragezeichen machen, weil ich hätte erwartet, dass die Person mal drauf klickt.

Es können immer Fehler passieren, aber das ist halt weird.

Das andere war dann, es gab internationale Sprecherinnen.

Beispiel, meine jetzt Kollegin Diana Günther.

Hört sich jetzt nicht so international an, die ist auch tatsächlich nicht Deutsche, wohnt halt in Berlin.

Und warum ist das so, warum ist das eine internationale Sprecherin?

Weil sie halt damals bei der einen Episode war, zu Agile Meets Architecture und das war eine englischsprachige Episode und dann hat das System irgendwie gesagt, also nicht hat die AI irgendwie etwas generiert, was hat gesagt, Leute, die in englischsprachigen Episoden sind, sind internationale Gäste und das ist halt Quatsch.

Am Ende ist jetzt eben das Feature nicht live.

Ich weiß auch nicht, ob das ein wichtiges Feature ist.

Ihr könnt euch jetzt melden und sagen, das brauchen wir halt unbedingt.

Ich weiß nicht, wie wichtig das wirklich ist, ich fand das mit den Zusammenfassungen halt sehr wichtig.

Mit den Gästen bin ich mir nicht so sicher, da kann man ja auch Volltext-Suche machen auf der Webseite mit allen Episoden, aber das Ergebnis war halt einfach, also unterirdisch, ist halt so nicht zu benutzen, Null.

Was ich daran faszinierend fand, war… Und dann war halt wieder dieses Transkriptionsproblem, dass nämlich irgendwelche Sprecherinhalte nicht vernünftig extrahiert worden sind und wir haben jetzt 260 Episoden oder so, 80, 280, weiß nicht, also wahnsinnig viele Episoden, sodass man da das Mindestzeit-Reviewen müssen wahrscheinlich sogar explizit reineditieren müssen, also die Sprecher irgendwie auflisten müssen und das ist halt irgendwie auch wahnsinnig viel Aufwand.

Was ich faszinierend fand, war, weil du eben auch von Software-Erstellung ist, was Soziales auch gesprochen hast, wäre das mein Code gewesen, dann hättest du echt Probleme gehabt, mir den um die Ohren zu hauen, wie sage ich es richtig und vielleicht kennt auch der ein oder andere dieses Problem, man merkt, dass jemand im Team an seinem Code hängt, an seinen Ideen hängt, an seiner Technologie, die er reingebracht hat und in dem Fall fand ich das so klasse.

Ich selbst habe überhaupt keine Verbindung zu dem Code gehabt, ich habe einfach gesagt, gut, ist bescheuert der Code, löschen wir ihn, hat ein paar Token gekostet, keine Ahnung, 60 Cent, weg und das finde ich super, weil mir das einfach mehr Entscheidungsfreiheit gibt, dass ich einfach ein Proof-of-Concept machen kann und einfach sagen kann, nee, das war nichts, weg damit.

Diese Bindung zum Code ist weg, ich bin auf einer anderen Ebene.

Mein Problem ist, faire Betrachtung und ich fand das auch nicht offensichtlich, mein Learning oder meine Frage, die sich irgendwie daraus ergibt, ist, bei aller Freundschaft, aber Software-Ethik zum Streamen ist eine triviale Webseite, die ist wirklich trivial eigentlich.

Wenn wir da so etwas schon nicht hinbekommen und auf dieser Ebene fehlen, verstehe ich nicht, vielleicht gibt es ja irgendwo einen Technologiesprung, das kann immer mal passieren und die sind schwer vorhersehbar, aber im Prinzip ist das ein Desaster, was da produziert wird und ich verstehe nicht, wo dieser Hype herkommt, der hat besagt, dass man nicht mehr entwickeln lernen soll, das ist mit den Ergebnissen, die ich da zumindest auch wieder gesehen habe und ich sehe auch keine anderen Ergebnisse, ist das nicht rechtfertigbar.

Ich habe auch gerade eine Umfrage bei Mastodon und bei LinkedIn laufen, wo die Menschen sagen können, wie viel Produktivitätsvorteil sie eigentlich bei Coding tatsächlich jetzt sehen und da gibt es wahnsinnig wenig Antwortmöglichkeiten, sind halt ein Decrease, also Abnahme der jetzigen Produktivität, dann 1 bis 2, also dass man maximal doppelt so schnell wird, das ist die andere Kategorie, dann 2 bis 5 und ich glaube ich mehr als 5 und ich kann mal gucken, ich hatte vorhin die auch irgendwie rumgeschickt, genau also bei Mastodon ist es halt so, dass 40 Prozent sagen, es gibt eine Abnahme, 50 Prozent haben 1 bis 2, 8 Prozent haben 2 bis 5 und 2 Prozent haben mehr als 5, also mehr als Faktor 5, also nicht 40 Prozent sagen, es wird langsamer, bei LinkedIn sind es 13 Prozent Abnahme, 58 Prozent 1 bis 2 mal, also Faktor 1 bis 2, 19 Prozent 2 bis 5 und dann 9 Prozent mehr als 5, das bedeutet, das was wir hier beobachten, ist meiner Ansicht nach nicht außergewöhnlich, also das ist halt eher eine Erfahrung, die wir teilen als Branche, das war für mich auch die Motivation, die Umfrage zu machen, also nicht Urauslöser war halt, dass es diese Paper gab, von wegen Majority View on AI, wo halt im Prinzip das drin stand, dass also die meisten Leute AI-pessimistisch sind, dann hatte ich eine Diskussion auf Mastodon mit dem Johannes Link, der mir gesagt hat, naja, also ich sehe jetzt wieder andere Leute und das hatte dann den Aufschlag gegeben, halt diese Umfrage zu machen und die sagt eigentlich, also ich habe es ja vorhin auch gesagt und vielleicht kommen wir noch dazu in den letzten 10 Minuten, also wenn ich hätte, es war etwas nicht, wie wir alles an der Webseite machen, ich kenne Jackal nicht besonders gut, mir hilft JetGPT dabei halt massiv.

Es gibt also einen, meiner Ansicht nach, einen Vorteil, aber das andere, was wir halt beobachten und für mich persönlich ist der Vorteil vor allem, ich wage mich da halt ran und ich kriege halt Dinge schneller gelöst in System, die ich halt irgendwie nicht besonders gut verstehe, aber zu glauben, dass so ein System Software entwickeln kann und das halt irgendwie hinbekommt, ist im Moment durch nichts gedeckt.

Absolut, also ich finde es auch schwierig, das Pendel schwingt hin und her, ja, anfangs waren wir alle begeistert, hey, das Teil, ich sage ihm, programmier mir einen Taschenrechner in HTML mit JavaScript und CSS und pump, ist der Taschenrechner da, dass der nach iOS aussieht, daran haben wir uns nicht gestört, aber es ist halt ein Anzeichen, dass es irgendwo aus einem Merkmalsraum runterlädt, ja und JavaScript, HTML, Python, da sind die LLMs sehr gut und momentan schwingt das Pendel so ein bisschen zurück, weil wir dann doch merken, ja, wir wollen vielleicht was mit Java machen und da habe ich mich letztens auch mit der KI unterhalten, sie hat sich 70 Paper runtergeladen und ich weiß nicht, wie tragfähig die Zahlen sind, ja, aber bei Python ist so die Erfolgswahrscheinlichkeit, Lösungswahrscheinlichkeit, keine Ahnung, was es genau ist, so bei 90 Prozent, ja, hört sich gut an, bei Java wird dann so, ich sage mal 82 ausgegeben, wo man sagt, kann ich noch mit leben und dann habe ich gesagt, du, wie sieht denn das mit den Java-Versionen aus, da hat er gesagt, ja, also bei Java 8 bin ich sogar bei 90 Prozent, Java 21 knall ich runter 50, jetzt sind wir bei Java 25, ja, das sind dann so Sachen, wo man auf einmal gegen Wände läuft, die man nicht sieht und ich finde es wichtig, dass wir diese Wände identifizieren, verstehen und gucken können, was wir besser machen können, um da noch mal zurückzukommen auf das Problem mit der Gästeliste, die KI, die arbeitet gern mit JavaScript und deswegen hat die mit JavaScript das implementiert, das ist ihre implizite Architektur und jetzt sind wir hier bei Software-Architektur im Stream, wo ist die Architektur, wer gibt der Maschine eine Architektur mit und ich glaube, wenn wir das besser erarbeiten würden, dass wir der Maschine sagen würden, du, hier ist Jekyll, hier sind deine Constraints, bitte nicht einfach ins Markdown JavaScript einbauen, ja, ich glaube, damit könnten wir weiterkommen.

Also bei der Gästeliste ist es halt so, also wenn jemand zu mir gekommen wäre und gesagt hätte, wir bauen mal so eine Gästeliste, ich hätte halt wahrscheinlich ein großes Markdown-Fall gemacht, wenn diese Person mir dann gesagt hätte, nee, ich will, dass es halt irgendwie gesucht wird, vielleicht wäre ich auf die Idee gekommen, das mit JavaScript zu machen, aber ich bin mir nicht sicher, es kann sehr gut sein, dass ich einfach nicht da einen blinden Fleck gehabt hätte und es halt irgendwie nicht gemacht hätte und ich glaube, das ist sozusagen die richtige Lösung, aber vielleicht spannender ist dann tatsächlich die Integration in die Webseite, also wir haben ja jetzt dieses Transcript, die Zusammenfassung und die Stichpunkte und da war die Frage, wie wir es halt in die Webseite bekommen und da hattest du ja auch dann Cloud Code, glaube ich, irgendwie losgeschickt und gesagt, mach mal.

Willst du erzählen, wie da die erste Lösung aussah?

Ich glaube, du kannst dich da noch besser daran erinnern.

Ich glaube, er hat irgendwie ein Datafile aufgebaut, ein YAML-File.

Ja, genau, also was da passiert ist und das ist also der Grund, warum ich die Lösung halt erstmal schwierig fand, war, weil es halt irgendwie so ein Alien war und das ist ein bisschen nachvollziehbar und das hatten wir vorhin ja auch schon mal diskutiert und das ist ja auch nur Ästhetik, aber es war irgendwie ein eigenes Verzeichnis und dann sind da diese Geschichten passiert.

Ich muss ja jetzt wissen, für welche der Episoden es überhaupt eine Transkription gibt, weil sonst kann ich die ja nicht rendern.

Die Lösung, die dort implementiert worden ist, es gibt einen YAML-File, wo das drinsteht.

Das fand ich weird, weil das ist das erste YAML-File gewesen, was wir da drin hatten und dann war halt das Zweite.

Für mich hat sich das auch komisch angeführt und dann gab es halt irgendwie die andere Geschichte und das war, wie kriege ich jetzt dieses Transcript überhaupt auf die Webseite.

Was da passiert ist, ist, dass es die Episodenseite gab.

Die gibt es ja eh für alle Episoden, auch für die, die ich transkriptierten und dann ist eine Lösung entstanden, wo in diese Seite die anderen drei Dateien inkludiert worden sind und dann Anchor gebaut worden sind.

Was also dazu führt, dass ich eine Episodenseite habe.

Das ist oben das Video auf PeerTube, das Video auf YouTube, der Podcast.

Dann die Zusammenfassung, Stichpunkte und dann die Transkription, was dazu führt, dass diese Webseite plötzlich wahnsinnig lang ist und im Wesentlichen aus dem Transkription besteht, weil dieses Ding eben natürlich die meisten Worte enthält.

Also wie soll ich sagen, nicht Software-Editor im Stream war oder ist, glaube ich, möglicherweise immer noch in diesem 512 Kilobyte Club.

Meine persönliche Webseite möglicherweise auch.

Eigentlich ist das eine Webseite, die so kleine Webseiten hat, kleine Webpages hat und das war eigentlich eine Sache, die ich irgendwie ganz gut fand und ich fand das da halt irgendwie weird und auch unnötig aufgeblasen.

Und es hat sich dann herausgestellt, das haben wir glaube ich tatsächlich erst zu der Diskussion zu dieser Folge herausgefunden, dass du, Claude, gesagt hast, man braucht etwas minimal Invasives.

Das war das, was du gesagt hast.

Und das ist in gewisser Weise passiert, weil die Markdown-Files für die Episoden sind unverändert.

Das Template hat sich geändert.

Das Template guckt jetzt in dem YAML nach, ob es die Übersetzung gibt und inkludiert die.

Also war das in gewisser Weise nicht zielerreicht.

Das fand ich lustig, weil ich hatte gedacht, naja, das ist eine Implementierungsvariante, die aus irgendwelchen Gründen von der AI gekommen ist und das ist problematisch.

Und was dann passiert ist in der Folge, ist, dass ich mich mal hingesetzt habe und einmal das Ding deutlich umgestellt habe.

Und jetzt ist es halt so, dass es diese drei Dateien gibt.

Da gibt es irgendwie Links dazwischen und diese Links werden gerendert, wenn die Dateien vorhanden sind.

Das heißt also, dass das Template von der Episode sagt, ich gucke jetzt nach, sind die Dateien da für die Zusammenfassung, für die Transkription und so weiter.

Dann rendere ich diese Links da rein, sonst nicht.

Das YAML-File ist damit eliminiert.

Ich musste, um diese Links zu rendern, in den Dateien die Episoden-Nummer aufnehmen.

Das heißt, ich habe letztendlich alle Episoden einmal automatisiert durchgeackert und habe da die Episoden-Nummer reingepackt.

Also ein Skript hat das getan.

Und dadurch haben wir jetzt eben diese vier Links.

Und im Rahmen dieser Aktion sind noch diverse andere Sachen entstanden.

Also zum Beispiel haben wir das jetzt mit YouTube und PeerTube so gemacht, dass man erstmal sagen muss, dass die Sachen tatsächlich embeddet sein sollen.

Ich habe ein paar Sachen hübscher gemacht, den Überblick hübscher und so weiter.

Und dadurch ist eben auch dieses Alien und die eigenen CSS-Dateien und so das komplett eliminiert.

Das hätte ich vielleicht hinbekommen ohne GTPT-Unterstützung, aber dann hätte es länger gedauert.

Das heißt, ich kann mir nicht vorstellen, solche Sachen zu entwickeln, ohne auf ein LLM zurückzugreifen.

Und die andere Seite, die spannend ist, ist nicht dieser Constraint, der dazu geführt hat, dass diese Lösung tatsächlich problematisch ist.

Der ist eigentlich von draußen reingekommen.

Und das Spannende, was du jetzt erzählt hast von der Lösung ist, da ist eine grundlegende Entscheidung getroffen worden in der Umsetzung und durch die Constraints von Jekyll zieht es einiges nach sich.

Denn als ich das umgesetzt habe, ist es reingekommen, dass wir gesagt haben, ja, okay, wir haben schon die Videos, wir haben schon den Podcast drin, wir haben den MP3 untereinander, wir haben den Abstract noch da drin.

Setz mal die anderen Sachen drunter.

Und das heißt, wir mussten inkludieren und ein Include geht nur auf das Include-Verzeichnis, nicht auf irgendwelche anderen Summaries-Verzeichnisse oder so.

Und deswegen mussten eben diese Summaries und die Transkription auch in das Include-Verzeichnis, wo eigentlich Header, Footer und sowas drin ist und CSS, total hässlich.

Und dadurch, dass bei deiner Umsetzung die Entscheidung getroffen worden ist, kommen wir setzen das auf eigene Seiten.

Wir haben da Links.

War das dann auf einmal möglich, das sauber in die Folder aufzuteilen?

Genau.

Und das ist halt so ein bisschen der Punkt.

Ich glaube, du hast es gerade sehr gut gesagt.

Die Lösung hat partiell eigentlich gegen Jekyll und dieses System gearbeitet.

Und das ist eine Lösung, die irgendwie funktioniert, aber sie arbeitet dagegen.

Und da ist die zweite Iteration dann irgendwie anders.

Da ist auch die Frage, wie soll ich sagen, ich weiß nicht, ob ich exakt diese Lösung umgesetzt hätte, wenn es nicht die erste Lösung gegeben hätte, also evolutionäre Architekturentwicklung.

Aber ja, ich will noch eine Sache loswerden.

Also der Ingo Eichhorst, der war ja auch schon hier im Stream, hat hier einen Kommentar hinterlassen.

In meinen Augen eine ganz normale Technologie-Adaptionskurve.

Erstmal geht es nach unten und dann gibt es Produktivitätsgewinne auf lange Sicht.

Also ich habe das erste deutschsprachige Spring-Buch geschrieben und ich habe auch das erste deutschsprachige Buch geschrieben über Microservices.

Bei Spring war es so, dass von Anfang an sofort deutlich offensichtlich war, zumindest für mich, dass das die Lösung ist, die ich Java I vorziehen würde.

Und ich will das gar nicht im Produktivitätsgewinne sozusagen ausdrücken, das ist halt schwierig, das ist halt ein Framework.

Aber die Vorteile waren halt evident.

Und also mindestens mit dem Stand, also nicht Java I, hat sich auf gut Rund dessen weiterentwickelt und ist heute was anderes als damals.

Aber das war klar und das hat dort auch viele Leute überzeugt.

Bei Microservices kann man darüber diskutieren.

Meiner Ansicht nach ist das eine Lösung für einige spezielle Punkte.

Ich fand es interessant für bestimmte Sachen, das war was anderes.

Eine Technologie, die kein Produktivitätsgewinn, also dass das jetzt keine Produktivitätsgewinne verspricht oder keine großen, da scheinen wir uns ja einig zu sein.

Ich verstehe nicht, woher der Optimismus kommt, dass es einen Produktivitätsgewinn auf lange Sicht geben soll.

Denn dafür gibt es halt im Moment keinen Hinweis.

Es ist extrem schwer, die Zukunft hier zu sagen, also aus offensichtlichen Gründen.

Deswegen muss man das abwarten und nicht, keine Ahnung, vielleicht ist es halt so, dass wir dahin kommen, dass es da irgendetwas gibt, aber das ist halt im Moment nicht absehbar.

Und nur nochmal, um es deutlich zu sagen, mindestens die Leute in der Mastodon-Community sagen, dass halt bei Coding eine Abnahme der Produktivität durch AI-Systeme stattfindet.

Und das sind 40 Prozent.

50 Prozent haben einen Faktor von 1 bis 2.

Das ist für mich ein überraschendes Ergebnis und das ist auch nichts, was bei LinkedIn halt reproduzierbar ist.

Also es hängt sehr sicher von der sozialen Gruppe ab.

Aber das ist nichts, worauf man jetzt irgendwie sagen kann, wir möchten noch zwei, drei Sachen ändern und dann ist es besser.

Keine Ahnung.

Also muss man darüber diskutieren.

Ich habe mir bewusst überlegt, ob ich die Frage stelle, also welche Vorteile erwartet ihr über die Zukunft.

Ich habe das halt gelassen, weil ich glaube, das bringt halt nichts.

Also es bringt deswegen nichts, weil das ist halt ein totales Glaskugellesen.

Da kann man halt irgendwelche Zahlen schießen und das ist ja beliebig.

Wir müssen uns aber tatsächlich eben in die Augen gucken und halt sehen, dass im Moment mindestens die Mastodon-Community, ich unterstelle, dass die irgendwie technischer ist.

Keine Ahnung, wie ich das ausdrücken soll.

Und es sind auch meine Follower, also das ist eine gewisse Auslese.

Aber diese 40 Prozent ist halt irgendwie krass.

Also das hätte ich auch nicht erwartet.

Wir haben da glaube ich noch viele spannende Sachen vor uns.

Jetzt gucke ich mal kurz auf die Planung.

Nächste Woche ist die Episode am 6.

Das ist der Donnerstag.

Da spricht Lisa mit Aino darüber, ob… Moment, erstmal ist es auf Englisch.

Und es geht um das Thema Teamwork.

Do we still need to talk about it?

Und das wird dann, glaube ich, eine besonders spannende Folge.

Also wie gesagt, nächste Woche dann tatsächlich am Donnerstag zur gewohnten Zeit, also um 13 Uhr, nicht am Freitag.

Und dann mit Lisa und Aino.

Vielen Dank an dich, Ralf.

Vielen Dank an die ZuschauerInnen.

Und vielleicht sehen wir uns dann bei einer der folgenden Folgen.

Bis dann.

Danke für die spannende Diskussion.

Tschau.