# Domain-Driven Design in der Praxis - Von der Theorie zur Implementierung

Domain-Driven Design (DDD) ist ein mächtiger Ansatz zur Entwicklung komplexer Softwaresysteme. Dieser Artikel beleuchtet die praktische Umsetzung von DDD anhand konkreter Implementierungsstrategien und Architekturmuster.

## Taktisches Design - Die Bausteine der Implementierung

Das taktische Design bildet das Fundament für die konkrete Implementierung von DDD. Es definiert wichtige objektorientierte Konzepte:

- **Entities**: Objekte mit einer eindeutigen Identität (z.B. eine Person oder ein Produkt)
- **Value Objects**: Unveränderliche Wertobjekte ohne eigene Identität (z.B. Geldbeträge oder Maßeinheiten)
- **Aggregates**: Cluster von Entities und Value Objects mit definierten Konsistenzgrenzen
- **Domain Events**: Wichtige fachliche Ereignisse in der Domäne
- **Repositories**: Bieten eine abstrakte Sicht auf Sammlungen von Aggregates
- **Factories**: Erzeugen komplexe Value Objects oder Aggregates
- **Services**: Kapseln übergreifende Geschäftslogik

## Architekturmuster für DDD

### Schichtenarchitektur (Layering)

Die klassische Drei-Schicht-Architektur separiert:
- UI-Schicht
- Geschäftslogik-Schicht  
- Persistenz-Schicht

Die Abhängigkeiten verlaufen dabei von oben nach unten. Ein Nachteil ist, dass die Geschäftslogik von der Persistenzschicht abhängig ist.

### Hexagonale Architektur 

Die hexagonale Architektur (auch Ports & Adapters) bietet eine elegante Alternative:

- Der Geschäftslogik-Kern definiert Ports (Schnittstellen)
- Adapter implementieren diese Ports für UI, Persistenz etc.
- Alle Abhängigkeiten zeigen nach innen zum Kern
- Bessere Testbarkeit durch klare Isolation der Geschäftslogik

### Event Sourcing und CQRS

Event Sourcing speichert die Historie von Zustandsänderungen als Events. CQRS (Command Query Responsibility Segregation) trennt Lese- und Schreiboperationen. Diese Muster sind optional und sollten nur eingesetzt werden, wenn sie echten Mehrwert bieten.

## Praktische Umsetzung am Beispiel

Am Beispiel eines E-Commerce-Systems mit Lieferungsverwaltung:

```java
// Entity
class Paket {
    private PaketId id;
    // ...
}

// Value Object  
class Adresse {
    private final String strasse;
    private final String ort;
    // immutable...
}

// Aggregate
class Lieferung {
    private LieferungId id;
    private Paket paket;
    private Adresse zielAdresse;
    private Status status;
    
    public void ausliefern() {
        // Geschäftslogik...
    }
}
```

## Empfehlungen für die Praxis

1. Starten Sie mit dem Big Picture Event Storming für den Überblick
2. Identifizieren Sie die Core Domain und Bounded Contexts
3. Wählen Sie für jeden Bounded Context die passende Implementierungsstrategie
4. Nutzen Sie hexagonale Architektur oder Schichten zur Strukturierung
5. Setzen Sie Event Sourcing und CQRS gezielt ein
6. Fokussieren Sie sich auf die Abbildung der Geschäftslogik

## Fazit

DDD ist kein Selbstzweck - der Fokus liegt auf der effektiven Umsetzung von Geschäftsanforderungen. Die verschiedenen Implementierungsstrategien bieten einen Werkzeugkasten, aus dem situationsabhängig gewählt werden kann. Wichtig ist, die Komplexität der Domäne zu erkennen und die passenden Werkzeuge auszuwählen.

Der zusätzliche Implementierungsaufwand für DDD-Patterns lohnt sich besonders bei komplexer Geschäftslogik. Bei einfachen CRUD-Anwendungen können schlankere Ansätze wie Transaction Scripts ausreichend sein.