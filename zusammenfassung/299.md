# Wie Datenbanken die Architektur formen

Die Wahl der Datenbankarchitektur ist eine der wichtigsten Entscheidungen bei der Softwareentwicklung – sie beeinflusst nicht nur die technischen Implementierungsdetails, sondern prägt die gesamte Systemarchitektur. In einer aktuellen Episode von "Software-Architektur im Stream" widmet sich Eberhard Wolff dieser fundamentalen Frage und zeigt auf, wie verschiedene Datenbankansätze unsere Designentscheidungen formen.

## Das Objekt-Relational-Mismatch

Der Kern des Problems liegt in der grundlegenden Diskrepanz zwischen objektorientierten Modellen und relationalen Datenbanksystemen. Domain-Driven Design (DDD) lehrt uns, mit Aggregates, Entities und Value Objects zu denken – konzeptionellen Strukturen, die Geschäftslogik kapseln. Eine Bestellung ist beispielsweise ein Aggregate, das Bestellpositionen, Gesamtwert und Konsistenzregeln verwaltet.

Relationale Datenbanken hingegen funktionieren völlig anders. Sie normalisieren Daten in separate Tabellen, wodurch eine einzelne geschäftliche Entity mehrere Tabellen umfassen kann. Der Kunde lebt in der Customers-Tabelle, seine Adressen in einer separaten Addresses-Tabelle. Diese Normalisierung ermöglicht flexible Abfragen über Join-Operationen, führt aber zu einer fundamentalen Spannung: Soll die Datenbank oder das Objekt-Modell die Architektur-Entscheidungen treiben?

## Verschiedene Ansätze zur Modellierung

Martin Fowler's "Patterns of Enterprise Application Architecture" bietet einen hilfreichen Orientierungspunkt. Das Domain Model mit Datamapper folgt dem objektorientierten Purismus – die Datenbank bleibt hinter einer Abstraktionsschicht verborgen. Der OR-Mapper verwaltet die Transformation, und der Entwickler interagiert nur mit Objekten.

Das Active Record Muster, popularisiert durch Ruby on Rails, geht einen anderen Weg: Eine Klasse repräsentiert eine Tabelle, enthält aber auch die Persistierungslogik. Das Row Data Gateway reduziert dies noch weiter auf eine einfache Gateway-Schicht ohne Geschäftslogik.

Bei Transaction Scripts – Prozeduren, die direkt auf der Datenbankebene arbeiten – kollidieren Präsentation, Logik und Persistierung. Dies mag zunächst primitiv klingen, kann aber für einfache Datenmigrationen oder CRUD-Operationen völlig ausreichend sein.

## Der Preis der Flexibilität

Relationale Datenbanken bieten eine beeindruckende Flexibilität: Eine Ad-hoc-Abfrage kann spontan über fünf Tabellen hinweg Umsatzdaten aggregieren, ohne dass dies vorher geplant wurde. Die Query-Optimizer erledigen die schwere Arbeit. Dies funktioniert nur, weil alle Daten zentral verfügbar sind.

Dokumentendatenbanken wie MongoDB verfolgen einen anderen Weg. Ein Aggregate wird zu einem Dokument, was die Verteilung erleichtert, aber analytische Flexibilität kostet. Abfragen über mehrere Dokumente hinweg sind aufwendiger und schwerer zu optimieren.

## Fazit

Es gibt keine universelle Antwort auf die Frage, welche Datenbankarchitektur die beste ist. Domain-Driven Design passt hervorragend für komplexe geschäftliche Logik mit relationalen Datenbanken, erfordert aber einen konsequenten Ansatz. Für Systeme mit geringer Geschäftslogik und klaren Schnittstellendefinitionen können Transaction Scripts oder einfache Gateways angemessener sein. Dokumentendatenbanken eignen sich für flexible, verteilte Systeme, opfern aber Abfrage-Flexibilität. Die Entscheidung sollte auf den konkreten Anforderungen basieren, nicht auf architektonischen Dogmen. Letztendlich formen Datenbanken unsere Architektur – daher sollten wir diese Entscheidung bewusst treffen.